// Service: user-service
// Replication: master-slave (async), RF=3
// Sharding: key-based by user_id (user_id encodes shard id like "shard-uuid")
// Notes: FKs shown for clarity; in practice each shard DB holds its own partition.

Table users {
  id         bigint       [pk, increment]                     // internal numeric PK
  user_id    varchar(64)  [unique, note: 'Stable external ID with shard prefix']
  shard_id   int          [not null, note: 'For routing; also in JWT']
  email      varchar(120) [unique, not null]
  pass_hash  varchar(255) [not null]
  name       varchar(100) [not null]
  created_at timestamp    [default: `now()`]
  updated_at timestamp    [default: `now()`]

  indexes {
    shard_id                // read routing
    (email)                 // login path
    (user_id)               // lookups by external id
  }
}

Table profiles {
  user_id     varchar(64) [pk, note: 'Same as users.user_id']
  description text
  city_id     bigint
  education   jsonb
  hobby       jsonb
  updated_at  timestamp    [default: `now()`]

  indexes {
    city_id
  }
}

Table cities {
  id         bigint       [pk, increment]
  name       varchar(120) [unique, not null]
}

Table interests {
  id         bigint       [pk, increment]
  name       varchar(120) [unique, not null]
}

Table interest_users {
  user_id     varchar(64) [not null]
  interest_id bigint      [not null]

  indexes {
    (user_id, interest_id) [pk, name: 'pk_interest_users']  // composite PK
    user_id                 [name: 'idx_interest_users_user']
    interest_id             [name: 'idx_interest_users_interest']
  }
}

Table follows {
  user_id    varchar(64) [not null]  // follower
  target_id  varchar(64) [not null]  // followee
  created_at timestamp    [default: `now()`]

  indexes {
    (user_id, target_id) [pk, name: 'pk_follows']
    user_id              [name: 'idx_follows_user']
    target_id            [name: 'idx_follows_target']
  }
}

Table friends {
  user_id    varchar(64) [not null]
  friend_id  varchar(64) [not null]
  created_at timestamp    [default: `now()`]

  indexes {
    (user_id, friend_id) [pk, name: 'pk_friends']
    user_id              [name: 'idx_friends_user']
    friend_id            [name: 'idx_friends_friend']
  }
}

Table relationships {
  user_id    varchar(64) [not null]
  related_id varchar(64) [not null]
  type       int         [not null, note: '1=Follow, 2=Friend, 3=Block (see code)']
  created_at timestamp    [default: `now()`]

  indexes {
    (user_id, related_id, type) [pk, name: 'pk_relationships']
    user_id                     [name: 'idx_relationships_user']
    related_id                  [name: 'idx_relationships_related']
    (user_id, type)             [name: 'idx_relationships_user_type']
  }
}

/* Top-level refs (diagram only; enforce per-shard in practice) */
Ref: users.user_id  < profiles.user_id
Ref: cities.id      < profiles.city_id

Ref: users.user_id  < interest_users.user_id
Ref: interests.id   < interest_users.interest_id

Ref: users.user_id  < follows.user_id
Ref: users.user_id  < follows.target_id

Ref: users.user_id  < friends.user_id
Ref: users.user_id  < friends.friend_id

Ref: users.user_id  < relationships.user_id
Ref: users.user_id  < relationships.related_id
